use colabrodo_server::server::ciborium::value::Value;
use colabrodo_server::{server::*, server_messages::*};
use std::sync::{Arc, Mutex};

/// Struct to hold our state
pub struct PingPongState {
    count: u64,
}

// This macro is complicated but does a lot for you.
// - First it sets up a function called ping_pong (arg 1),
// - that takes an Arc<Mutex<PingPongState>> (arg 2),
// - that, when registered on the server, will be called "ping_pong"
// - with a description.
// It then lists the available arguments to the method, with a name, type, and description.
// Finally, it takes the actual code you wish to run when the method is invoked.
make_method_function!(ping_pong,
    PingPongState,
    "ping_pong",
    "A simple method that sends back exactly what it gets.",
    | first_arg : Value : "Required first argument" |,
    | second_arg : Option<Value> : "Optional second argument" |,
    {
        println!("Function called {} times: {:?} {:?}", app.count, first_arg, second_arg);
        Ok(Some(Value::Array(vec![first_arg])))
    });

/// Set up our server
fn setup(state: ServerStatePtr) {
    let ping_pong_state = Arc::new(Mutex::new(PingPongState { count: 0 }));

    log::debug!("Initializing ping pong state");

    let mut state_lock = state.lock().unwrap();

    // Create a component to hold the method
    // Note that we call [create_ping_pong], which is generated by the above macro. It takes care of setting up everything for you.
    let ptr = state_lock
        .methods
        .new_owned_component(create_ping_pong(ping_pong_state));

    // Attach the new method to our document
    state_lock.update_document(ServerDocumentUpdate {
        methods_list: Some(vec![ptr]),
        ..Default::default()
    })
}

#[tokio::main]
async fn main() {
    println!("Connect clients to localhost:50000");
    let opts = ServerOptions::default();

    let state = ServerState::new();

    setup(state.clone());

    server_main(opts, state).await;
}
